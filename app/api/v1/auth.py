"""
Authentication API endpoints.
Provides login functionality and token validation using TMS integration.
"""
from fastapi import APIRouter, Depends, HTTPException, status, Header, Request
from sqlalchemy.ext.asyncio import AsyncSession
from pydantic import BaseModel, Field
from typing import Optional

from app.core.database import get_db
from app.services.user_service import UserService
from app.core.tms_client import tms_client, TMSAPIException
from app.core.security import decode_nextauth_token, SecurityException
from app.schemas.user import UserResponse
from app.repositories.user_repo import UserRepository

router = APIRouter()


class LoginRequest(BaseModel):
    """Login request schema for proxy authentication."""
    token: str = Field(..., description="TMS JWT token to validate")


class LoginResponse(BaseModel):
    """Login response schema."""
    success: bool
    user: UserResponse
    message: str = "Login successful"


class TokenValidationResponse(BaseModel):
    """Token validation response schema."""
    valid: bool
    user: Optional[UserResponse] = None
    message: str


@router.post("/login", response_model=LoginResponse)
async def login(
    login_request: LoginRequest,
    request: Request,
    db: AsyncSession = Depends(get_db)
):
    """
    Validate NextAuth JWT token and sync user data.

    This endpoint accepts JWT tokens generated by GCGC TMS's /api/v1/auth/token endpoint.
    The token contains all user information and is signed with NEXTAUTH_SECRET.

    **Flow:**
    1. Decode and validate NextAuth JWT token
    2. Extract user information from token
    3. Sync user data to local database
    4. Return user profile

    **Request Body:**
    ```json
    {
        "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
    }
    ```

    **Returns:** User profile if authentication is valid

    **Errors:**
    - 401: Invalid or expired token
    - 500: Internal server error
    """
    try:
        # Decode the NextAuth JWT token
        token_payload = decode_nextauth_token(login_request.token)

        # Extract user data from token
        tms_user_id = token_payload.get("id")
        if not tms_user_id:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Token does not contain user ID"
            )

        # Prepare user data from token for syncing
        tms_user_data = {
            "id": tms_user_id,
            "email": token_payload.get("email"),
            "name": token_payload.get("name"),
            "role": token_payload.get("role"),
            "hierarchyLevel": token_payload.get("hierarchyLevel"),
            "image": token_payload.get("image"),
        }

        # Sync user to local database
        user_repo = UserRepository(db)
        user = await user_repo.upsert_from_tms(tms_user_id, tms_user_data)
        await db.commit()

        # Build user response
        user_service = UserService(db)
        user_response = user_service._map_user_to_response(user, tms_user_data)

        return LoginResponse(
            success=True,
            user=user_response,
            message="Login successful"
        )

    except SecurityException as e:
        # Enhanced error message for token validation failures
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail={
                "error": "authentication_failed",
                "message": str(e),
                "hint": "Please ensure you're using a valid JWT token from GCGC authentication"
            }
        )
    except Exception as e:
        # Enhanced error message for unexpected errors
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f"Login error: {type(e).__name__}: {str(e)}", exc_info=True)

        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail={
                "error": "internal_server_error",
                "message": "Failed to process login request",
                "type": type(e).__name__,
                "hint": "Please contact support if the issue persists"
            }
        )


@router.post("/validate", response_model=TokenValidationResponse)
async def validate_token(
    request: LoginRequest,
    db: AsyncSession = Depends(get_db)
):
    """
    Validate TMS token without syncing user data.
    
    Lightweight endpoint to check if a token is valid.
    Useful for client-side token validation.
    
    **Request Body:**
    ```json
    {
        "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
    }
    ```
    
    **Returns:**
    ```json
    {
        "valid": true,
        "user": { ... },
        "message": "Token is valid"
    }
    ```
    
    **Note:** This endpoint is faster than `/login` as it doesn't sync user data.
    """
    try:
        # Just fetch user from TMS without syncing to DB
        tms_user_data = await tms_client.get_current_user_from_tms(request.token, use_cache=True)
        
        # Create minimal user response
        user_response = UserResponse(
            id="temp",  # Temporary ID since we're not syncing
            tms_user_id=tms_user_data["id"],
            email=tms_user_data.get("email", ""),
            username=tms_user_data.get("username", ""),
            first_name=tms_user_data.get("firstName", ""),
            last_name=tms_user_data.get("lastName", ""),
            middle_name=tms_user_data.get("middleName"),
            name=tms_user_data.get("name"),
            display_name=tms_user_data.get("name") or f"{tms_user_data.get('firstName', '')} {tms_user_data.get('lastName', '')}".strip(),
            image=tms_user_data.get("image"),
            role=tms_user_data.get("role", "MEMBER"),
            position_title=tms_user_data.get("positionTitle"),
            division=tms_user_data.get("division"),
            department=tms_user_data.get("department"),
            section=tms_user_data.get("section"),
            custom_team=tms_user_data.get("customTeam"),
            is_active=tms_user_data.get("isActive", True),
            is_leader=tms_user_data.get("isLeader", False),
            last_synced_at=None,
            created_at=None,
            settings=None,
        )
        
        return TokenValidationResponse(
            valid=True,
            user=user_response,
            message="Token is valid"
        )
        
    except TMSAPIException as e:
        return TokenValidationResponse(
            valid=False,
            user=None,
            message=f"Token validation failed: {str(e)}"
        )
    except Exception as e:
        return TokenValidationResponse(
            valid=False,
            user=None,
            message=f"Validation error: {str(e)}"
        )


@router.get("/me", response_model=UserResponse)
async def get_authenticated_user(
    authorization: str = Header(..., description="Bearer token"),
    db: AsyncSession = Depends(get_db)
):
    """
    Get current authenticated user (alternative endpoint).
    
    This is an alias to `/api/v1/users/me` for convenience.
    Validates token and returns full user profile.
    
    **Authentication:** Required (Bearer token in Authorization header)
    
    **Headers:**
    ```
    Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
    ```
    
    **Returns:** Full user profile with local settings
    """
    if not authorization or not authorization.startswith("Bearer "):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authorization header format. Use 'Bearer <token>'"
        )

    token = authorization.split(" ")[1]

    try:
        user_service = UserService(db)
        user = await user_service.get_current_user(token)
        return user
    except TMSAPIException as e:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail=f"Failed to fetch user from TMS: {str(e)}"
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Internal server error: {str(e)}"
        )


@router.post("/logout")
async def logout():
    """
    Logout endpoint (placeholder).
    
    Since this system uses TMS tokens, logout is handled client-side
    by discarding the token. This endpoint exists for API completeness.
    
    **Note:** In a production system, you might want to maintain a
    token blacklist or notify TMS of logout events.
    
    **Returns:**
    ```json
    {
        "success": true,
        "message": "Logged out successfully"
    }
    ```
    """
    return {
        "success": True,
        "message": "Logged out successfully. Please discard your token client-side."
    }


@router.get("/health")
async def auth_health_check():
    """
    Authentication service health check.
    
    Verifies connectivity to TMS API.
    
    **Returns:**
    ```json
    {
        "status": "healthy",
        "tms_connected": true,
        "message": "Authentication service is operational"
    }
    ```
    """
    try:
        tms_healthy = await tms_client.health_check()
        
        return {
            "status": "healthy" if tms_healthy else "degraded",
            "tms_connected": tms_healthy,
            "message": "Authentication service is operational" if tms_healthy else "TMS connection issues detected"
        }
    except Exception as e:
        return {
            "status": "unhealthy",
            "tms_connected": False,
            "message": f"Authentication service error: {str(e)}"
        }